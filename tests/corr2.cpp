// https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSAbAQwDtRkBSAJgCFufSAZ1QBXYskwgA5NwDMeFsgYisAag6yAwpgAeAB0zE8AW0wsCTBgHo0xUQQWYN2DgAYAgnIVKVmdVpYRUyNOWRcPN3cWJlNBPSYJVUECdB1/ABEklJAQXQMjU3NLDT4PdQ8CTGM9Zkr/TQIATwNo01UAFWcs4hFkAlVgM0MmImJ1AHZS91Vu3v69O2M8QUwAfSaDCamZmfbVZDFiMwJVgDdLESdZbZ3k1JzBETizdFXLAHcmRsFVRrxMBivc7KTAQPbAy4ASi2kR2OwICGWAFpnAdiEdzGcLn4NJkIVcbnCjgQxCwYeN0iVYTsOBTqTM7joHk8Wq8Pl8fgpCHhLKtHs8WOgINDaTxVMTSeTKdcJpSyrcUkyQPzWW8GJ9vqoAGYKXkql7CrbizAk4hk0W06Viy30gZDYgjEh2k4Ss2rVAAIyomD6htFxtNZMGLGGo1FCOWNplUcJqlOqDw6FUIhYCFY6AYmFeugkegcqBYfsmWXQOUqxCW0UqwpKstt8cTAdJZwTQpFkxt8pjkWpyR6fVUhFDTot8oZipytnsjlWacFmY0mgWqCWK3WzSu2FUq00JFQVLHqg9qFQDG36QLBJ7h6HDtGEEZk73IgcIdn6YXWmXq7WG03ql3OxSCPE8zwvENIVtOEQG3QDUAgODIWA1ZwNBVD2z4OkIhvctHTGbgADZUHyPD%2BH4ItYxmHc9wAOiOR5TBra4oPPS8Mlg2j0EvJjKKbM1VAAKgjQQD2mGksM8Q9j1PVRiOHYhcVxCBbzw/YC2SdQuAI1YACU8GABACGhNAWA00cxKJE1JRQtjFNkTJdP0wyaJskNRLhTtJIskCZLku8SDAMAlJU0Y1NM/pCMcgyjLCszi1dMlAogITER%2BOyHL06LIOjCS4T2EyzK0vy8IEw0Coi%2BKrP46i7Bo79llBSEaLRDETnxWtPLy2L%2BgE4rRhRMIyvUiqxQSzSCIgPqSFKyFsutXK62Y7CxJCp0PUwYAFAo209DozAGMa9ydjG0U9GA3auJDGs6SWsTPOpVaxgNDC%2BPNSYztUAgeicG75rlLyZmDeToHtVTysIkV7NULBM0qI6gf84gQZDRHxsI4gEEEaEYL0CAMcEOqXvxur2MCBgGDzBScv%2B6kAD8Ebw7aby1VQID0SDDxmC79q%2B1BGh46l7o8BY8HOSoQGpPIGDwZBCDtFHGfqtc/0E9mWJxh8JxQZ9XzWOcMyuJdFga9cDGcHItUWVYldBAT2YwoWxMfbW7BfGd9c/I2VxNv8uj0UTu2WypqlqHEtD/Vo/E6MJIgZsMtGjrcVgARyZsStSdMFB3Yi1fo63h%2BDwDnvLQVY/gBJM8ADiTImDmoRjDhoN0jjpnFj0H480RPPqYABrNYUwcBhkfkxdE8IgZgL2aWlhi8yZgzsYICYF99y0ifThg4Bi7hPAWYgU56lUGfCGM1Ay/%2BQE4yOmYARWI8jj76uaYqKp67qRcI5iKO248OOSDHl0YwIgGAOBqPzf%2BVMu5ty0pPDo2oEijAdvKRerMV5EEIhvLeO8dil3LlfQ%2BAkEF9AAbdR2ddQ71C/m0cef8O6kOgWEVQTB0BCkgYAmOsDgBT2YawwwyD06Z3QWvAiWCBg4JmHgy%2BSZD78F4VgKmUxHYKH6MYJgW0BEzGEUkdiKdFwqOcALeU2iIpQwsP3VYg88DD0EMBWgrg5rUm0cYdiwDQF4HARAAgwEuCOOMavZh7EWFCmMHY%2BxfixJjTuDkBIBw3EN2XjRdam1CxIWYTRZ6wEHHPykEhBg0gACsUhSAsGkK4YpqBpCaDIrwJIohxA4i4LIWgxSCBlNyUhXuIBZAFJovYgAnAADloIMgALKM2g/SuCjIKeMRg0hRnFNKVIcppBKlSGKYIEArhSBtJWbk0gcBYBIDQNUaxhhyCUFOXoc5xAUDMDYAU1wOydSgMMFsiAqwvmuEoEhD07TSAel1MQRo0gWmkFOYUAgAB5FgDBQX7NIFgNRbBMwAvwEcPoot9oAt0D6F8kgpDgpUQCAFVBk6XBBdIWQNEuB9OKZmNgCI6CkAWJgU40KvQ%2BjaZ875lBBB4AAF6CszLQJ5BTRlcHGK4cYozXAEQIpQFMWAdQhlLBATMwZSyQAKaQHZRKOmzUYGYYAzL6Bso5VyvolAvmrB%2BdQAAipSxosguD2NkARcYYz%2BkFIVYM55BEhm0EoPgOIzAEUHIFcK0V4rJXStlfKxVEBlWYFVVmSgmqXjwF1fqlps0jWMtNUgWgRqvomDBQch57AakCGlh6LZkAkLEXzKZaQSI7i4k4AXXgtBRmqCRNCrg/a7h1txHWrtfBalIi1FON2IZBBIgIIITZ9SJB0DyYUpZAL1k6EGQRJEBE%2B1KFYMAVQvTXA0VcKzXAhARxNPoABFcNzMz4XvdCap3aeCtPaUarpzSaIFN9WMwZXBpmyrdfQfJUhFklO3dITZ2zdk/sOTARAIB7B6BfJciA1zbksqzLeu59B3gOj0BWjdUgimwcResuQtBVDvEIAgVQu792Hv2FWs9l7L3fv2b%2B7pNLZBCeEyJkT8zoNbpo/BoQiG9nlILdILgknVnrN4/JpCpx3l4ALCAUZQA%3D
// https://abseil.io/blog/20180713-coroutine-types
#include <experimental/coroutine>
#include <numeric>

namespace stdx = std::experimental;
 
template <typename T> struct generator {
  struct promise_type {
    T current_value;
    stdx::suspend_always yield_value(T value) {
      this->current_value = value;
      return {};
    }
    stdx::suspend_always initial_suspend() { return {}; }
    stdx::suspend_always final_suspend() { return {}; }
    generator get_return_object() { return generator{this}; };
    void unhandled_exception() { std::terminate(); }
    void return_void() {}
  };

  struct iterator {
    stdx::coroutine_handle<promise_type> _Coro;
    bool _Done;

    iterator(stdx::coroutine_handle<promise_type> Coro, bool Done)
        : _Coro(Coro), _Done(Done) {}

    iterator &operator++() {
      _Coro.resume();
      _Done = _Coro.done();
      return *this;
    }

    bool operator==(iterator const &_Right) const {
      return _Done == _Right._Done;
    }

    bool operator!=(iterator const &_Right) const { return !(*this == _Right); }
    T const &operator*() const { return _Coro.promise().current_value; }
    T const *operator->() const { return &(operator*()); }
  };

  iterator begin() {
    p.resume();
    return {p, p.done()};
  }

  iterator end() { return {p, true}; }

  generator(generator const&) = delete;
  generator(generator &&rhs) : p(rhs.p) { rhs.p = nullptr; }

  ~generator() {
    if (p)
      p.destroy();
  }

private:
  explicit generator(promise_type *p)
      : p(stdx::coroutine_handle<promise_type>::from_promise(*p)) {}

  stdx::coroutine_handle<promise_type> p;
};

template <typename T>
generator<T> seq() {
  for (T i = {};; ++i)
    co_yield i;
}

template <typename T>
generator<T> take_until(generator<T>& g, T limit) {
  for (auto&& v: g)
    if (v < limit) co_yield v;
    else break;
}

template <typename T>
generator<T> multiply(generator<T>& g, T factor) {
  for (auto&& v: g)
    co_yield v * factor;
}

template <typename T>
generator<T> add(generator<T>& g, T adder) {
  for (auto&& v: g)
    co_yield v + adder;
}

int main() {
  auto s = seq<int>();
  auto t = take_until(s, 10);
  auto m = multiply(t, 2);
  auto a = add(m, 110);
  return std::accumulate(a.begin(), a.end(), 0);
}
